This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-06T03:51:16.720Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
config_manager.rs
main.rs
remote.rs
server.rs
system_info.rs

================================================================
Files
================================================================

================
File: config_manager.rs
================
// src/config_manager.rs

use serde::{Serialize, Deserialize};
use std::sync::{Arc, RwLock};
use notify::{Watcher, RecursiveMode, watcher, DebouncedEvent};
use std::sync::mpsc::{channel, TryRecvError};
use std::time::Duration;
use tokio::time::sleep;
use tokio::sync::watch;

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct RemotePylonConfig {
    pub ip: String,
    pub port: u16,
    pub token: String,
    // New optional name for a remote pylon.
    pub name: Option<String>,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Config {
    // The default local port Pylon will try to use.
    pub local_port: Option<u16>,
    // The token that remote clients must supply when polling /api/metrics.
    pub token: String,
    // New: the name of this local Pylon.
    pub name: Option<String>,
    // A list of remote Pylon instances to poll.
    pub remote_pylons: Option<Vec<RemotePylonConfig>>,
}

impl Default for Config {
    fn default() -> Self {
        Self {
            local_port: Some(6989),
            token: "default_token".into(),
            name: Some("Local Pylon".into()),
            remote_pylons: None,
        }
    }
}

pub fn load_config() -> Result<Config, config::ConfigError> {
    let settings = config::Config::builder()
        .add_source(config::File::with_name("config"))
        .build()?;
    settings.try_deserialize::<Config>()
}

/// Now accepts a shutdown receiver so it can exit gracefully.
pub async fn watch_config(config_arc: Arc<RwLock<Config>>, shutdown: watch::Receiver<bool>) {
    let (tx, rx) = channel();
    let mut watcher = watcher(tx, Duration::from_secs(2)).unwrap();
    if let Err(e) = watcher.watch("config.toml", RecursiveMode::NonRecursive) {
        println!("Failed to watch config.toml: {}", e);
        return;
    }

    loop {
        if *shutdown.borrow() {
            println!("Shutting down config watcher.");
            break;
        }

        match rx.try_recv() {
            Ok(event) => match event {
                DebouncedEvent::Write(path) => {
                    println!("Config file changed: {:?}", path);
                    if let Ok(new_config) = load_config() {
                        let mut config_lock = config_arc.write().unwrap();
                        *config_lock = new_config;
                        println!("Config reloaded.");
                    } else {
                        println!("Failed to reload config.");
                    }
                },
                _ => {},
            },
            Err(TryRecvError::Empty) => {
                sleep(Duration::from_secs(1)).await;
            },
            Err(TryRecvError::Disconnected) => {
                println!("Config watcher disconnected.");
                break;
            }
        }
    }
}

================
File: main.rs
================
// main.rs

mod config_manager;
mod system_info;
mod remote;
mod server;

use std::fs;
use std::path::Path;
use std::sync::{Arc, Mutex, RwLock};
use std::collections::HashMap;
use config_manager::Config;
use system_info::SystemData;
use remote::RemoteStatus;
use server::AppState;
use tokio::sync::watch;

fn ensure_config_exists() -> std::io::Result<()> {
    let config_path = "config.toml";
    if !Path::new(config_path).exists() {
        // The default configuration is embedded at compile time.
        // Make sure the path below is relative to your src folder or project root as needed.
        const DEFAULT_CONFIG: &str = include_str!("../config_default.toml");
        fs::write(config_path, DEFAULT_CONFIG)?;
        println!("Default configuration written to '{}'.", config_path);
    }
    Ok(())
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    // On startup, ensure that a config file exists.
    if let Err(e) = ensure_config_exists() {
        eprintln!("Failed to ensure config file exists: {}", e);
        // Depending on your needs, you might choose to exit here.
    }

    // Load the configuration (or use defaults if it fails).
    let initial_config = match config_manager::load_config() {
        Ok(cfg) => cfg,
        Err(e) => {
            println!("Failed to load config: {}. Using default.", e);
            Config::default()
        }
    };
    let config = Arc::new(RwLock::new(initial_config));

    // Create a shutdown channel.
    let (shutdown_tx, shutdown_rx) = watch::channel(false);

    // Spawn a task to watch the config file and reload on changes.
    let config_clone = Arc::clone(&config);
    tokio::spawn(config_manager::watch_config(config_clone, shutdown_rx.clone()));

    // Initialize system data and spawn a task to poll system metrics.
    let system_data = Arc::new(Mutex::new(SystemData::new()));
    let system_data_clone = Arc::clone(&system_data);
    tokio::spawn(system_info::poll_system_metrics(system_data_clone, shutdown_rx.clone()));

    // Initialize remote statuses and spawn a task to poll remote Pylons.
    let remote_statuses = Arc::new(Mutex::new(HashMap::<String, RemoteStatus>::new()));
    let config_clone2 = Arc::clone(&config);
    let remote_statuses_clone = Arc::clone(&remote_statuses);
    tokio::spawn(remote::poll_remote_pylons(config_clone2, remote_statuses_clone, shutdown_rx.clone()));

    // Determine which port to use (starting with the configured default, 6989).
    let base_port = config.read().unwrap().local_port.unwrap_or(6989);
    let server_port = server::find_open_port(base_port).await;
    if server_port != base_port {
        println!("Port {} was in use. Running on port {} instead.", base_port, server_port);
    }

    // Build our shared application state.
    let state = AppState {
        config: Arc::clone(&config),
        system_data: Arc::clone(&system_data),
        remote_statuses: Arc::clone(&remote_statuses),
    };

    // Start the web server and set up graceful shutdown.
    let server = server::run_server(server_port, state);

    tokio::select! {
        res = server => {
            res
        },
        _ = tokio::signal::ctrl_c() => {
            println!("Received ctrl+c, shutting down gracefully...");
            // Signal shutdown to all background tasks.
            let _ = shutdown_tx.send(true);
            Ok(())
        }
    }
}

================
File: remote.rs
================
// src/remote.rs

use std::sync::{Arc, Mutex};
use std::collections::HashMap;
use tokio::time::{sleep, Duration};
use chrono::{DateTime, Utc};
use serde::{Serialize, Deserialize};
use reqwest::Client;
use serde_json::Value;
use tokio::sync::watch;
use crate::config_manager::Config;

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct RemoteStatus {
    pub ip: String,
    pub port: u16,
    pub last_seen: Option<DateTime<Utc>>,
    pub data: Option<Value>, // remote metrics as JSON
    pub online: bool,
    // New: include the name from the configuration (if any)
    pub name: Option<String>,
}

/// Now accepts a shutdown receiver so it can exit gracefully.
/// Also performs peer discovery by reading the "remote_pylons" field returned
/// by remote servers and adding new ones to the polling list.
pub async fn poll_remote_pylons(
    config_arc: Arc<std::sync::RwLock<Config>>,
    remote_statuses: Arc<Mutex<HashMap<String, RemoteStatus>>>,
    mut shutdown: watch::Receiver<bool>
) {
    let client = Client::new();
    // Discovered peers (not in the initial config)
    let mut discovered_peers: Vec<crate::config_manager::RemotePylonConfig> = Vec::new();
    loop {
        tokio::select! {
            _ = shutdown.changed() => {
                if *shutdown.borrow() {
                    println!("Shutting down remote poller.");
                    break;
                }
            },
            _ = async {
                // Build list of all remotes to poll: config.remote_pylons + discovered_peers (deduplicated)
                let mut all_remotes: Vec<crate::config_manager::RemotePylonConfig> = Vec::new();
                {
                    let config = config_arc.read().unwrap().clone();
                    if let Some(remote_list) = config.remote_pylons {
                        all_remotes.extend(remote_list);
                    }
                }
                // Add discovered peers that are not already in all_remotes.
                for peer in discovered_peers.iter() {
                    let key = format!("{}:{}", peer.ip, peer.port);
                    if !all_remotes.iter().any(|r| format!("{}:{}", r.ip, r.port) == key) {
                        all_remotes.push(peer.clone());
                    }
                }
                
                for remote in all_remotes {
                    let key = format!("{}:{}", remote.ip, remote.port);
                    let url = format!("http://{}:{}/api/metrics", remote.ip, remote.port);
                    let req = client.get(&url)
                        .bearer_auth(remote.token.clone())
                        .timeout(Duration::from_secs(5))
                        .send()
                        .await;
                    let mut status = RemoteStatus {
                        ip: remote.ip.clone(),
                        port: remote.port,
                        last_seen: None,
                        data: None,
                        online: false,
                        name: remote.name.clone(),
                    };
                    match req {
                        Ok(resp) => {
                            if resp.status().is_success() {
                                if let Ok(json_data) = resp.json::<Value>().await {
                                    status.data = Some(json_data.clone());
                                    status.online = true;
                                    status.last_seen = Some(Utc::now());
                                    // Peer discovery: if the remote data contains "remote_pylons", add them
                                    if let Some(peers) = json_data.get("remote_pylons") {
                                        if let Some(array) = peers.as_array() {
                                            for peer_val in array {
                                                if let Ok(peer_config) = serde_json::from_value::<crate::config_manager::RemotePylonConfig>(peer_val.clone()) {
                                                    let peer_key = format!("{}:{}", peer_config.ip, peer_config.port);
                                                    if !discovered_peers.iter().any(|p| format!("{}:{}", p.ip, p.port) == peer_key) &&
                                                       peer_key != key { // avoid self
                                                        discovered_peers.push(peer_config);
                                                        println!("Discovered new peer: {}", peer_key);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        Err(e) => {
                            println!("Error connecting to remote {}: {}", key, e);
                        }
                    }
                    let mut statuses = remote_statuses.lock().unwrap();
                    statuses.insert(key, status);
                }
            } => {}
        }
        sleep(Duration::from_secs(10)).await;
    }
}

================
File: server.rs
================
// src/server.rs

use actix_web::{get, web, App, HttpResponse, HttpServer, Responder, middleware::Logger, HttpRequest};
use std::sync::{Arc, Mutex, RwLock};
use crate::system_info::SystemData;
use crate::remote::RemoteStatus;
use serde_json::json;
use std::collections::HashMap;

#[derive(Clone)]
pub struct AppState {
    pub config: Arc<RwLock<crate::config_manager::Config>>,
    pub system_data: Arc<Mutex<SystemData>>,
    pub remote_statuses: Arc<Mutex<HashMap<String, RemoteStatus>>>,
}

#[get("/")]
async fn index() -> impl Responder {
    let html = r#"<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Pylon Dashboard üöÄ‚ú®</title>
  <style>
    /* Global Styles */
    body {
      background-color: #121212;
      color: #e0e0e0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 0;
    }
    h1, h2, h3 {
      text-shadow: 0 0 5px rgba(0,255,255,0.5);
    }
    .container {
      width: 90%;
      margin: 20px auto;
      overflow-y: auto;
      max-height: 100vh;
      padding-right: 10px;
    }
    .card {
      background-color: #1e1e1e;
      padding: 20px;
      margin: 10px 0;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.5);
    }
    /* Gauges */
    .gauges {
      display: flex;
      justify-content: space-around;
      flex-wrap: wrap;
    }
    .gauge-container {
      text-align: center;
      margin: 20px;
      padding: 10px;
      border-radius: 10px;
    }
    .gauge {
      width: 180px;
      height: 180px;
      margin: auto;
      filter: drop-shadow(0 0 10px rgba(0, 255, 255, 0.7));
    }
    .gauge-label {
      margin-top: 8px;
      font-size: 1.2rem;
    }
    /* Local Services Status */
    .services {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 20px;
    }
    .service {
      text-align: center;
    }
    .service-light {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      margin: 0 auto;
      box-shadow: 0 0 5px;
    }
    /* Network Chart */
    .network-chart-container {
      position: relative;
      height: 300px;
      width: 100%;
    }
    #networkChart {
      width: 100% !important;
      height: 100% !important;
      background-color: #1e1e1e;
      border-radius: 8px;
      display: block;
    }
    /* Table Styling */
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }
    table, th, td {
      border: 1px solid #333;
    }
    th, td {
      padding: 8px;
      text-align: left;
    }
    th {
      background-color: #222;
    }
    /* Scrollbar Styling */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    ::-webkit-scrollbar-track {
      background: #1e1e1e;
    }
    ::-webkit-scrollbar-thumb {
      background: #333;
      border-radius: 4px;
    }
    /* Flashing Globe Animation for Remote Poll Indicator */
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.6; }
      100% { opacity: 1; }
    }
    .pulse {
      animation: pulse 2s ease-in-out infinite;
    }
  </style>
  <!-- Include ProgressBar.js and Chart.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/progressbar.js/1.0.1/progressbar.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <div class="container">
    <h1 id="localPylonName">Pylon Dashboard</h1>
    
    <!-- Local System Metrics Card -->
    <div class="card" id="localMetricsCard">
      <h2>Local System Metrics üíª</h2>
      <div class="gauges">
        <div class="gauge-container">
          <div id="cpuGauge" class="gauge"></div>
          <div class="gauge-label">‚ö° CPU Usage</div>
        </div>
        <div class="gauge-container">
          <div id="ramGauge" class="gauge"></div>
          <div class="gauge-label">üìä RAM Usage</div>
          <div id="ramUsageText" style="margin-top: 8px; font-size: 1rem;"></div>
        </div>
        <div class="gauge-container">
          <div id="diskGauge" class="gauge"></div>
          <div class="gauge-label">üíæ Disk Usage</div>
          <div id="diskUsageText" style="margin-top: 8px; font-size: 1rem;"></div>
        </div>
        <div class="gauge-container">
          <div id="cpuSpeedGauge" class="gauge"></div>
          <div class="gauge-label">üîß CPU Speed</div>
          <div id="cpuSpeedText" style="margin-top: 8px; font-size: 1rem;"></div>
        </div>
      </div>
      <!-- Local Services Status Lights -->
      <div class="services" id="servicesStatus">
        <!-- Filled dynamically -->
      </div>
      <div style="margin-top: 20px;">
        <h3>Other Metrics ‚è±Ô∏è</h3>
        <div>Uptime: <span id="uptime">0</span> seconds</div>
        <div>Load Average: <span id="loadAverage">0</span></div>
      </div>
    </div>
    
    <!-- Network Throughput Card -->
    <div class="card" id="networkCard">
      <h2>Network Throughput üåê</h2>
      <div class="network-chart-container">
        <canvas id="networkChart"></canvas>
      </div>
    </div>
    
    <!-- System Information Card -->
    <div class="card" id="systemInfoCard">
      <h2>System Information üìã</h2>
      <div id="systemDetails">
        <!-- Filled dynamically -->
      </div>
    </div>
    
    <!-- Top Processes Card -->
    <div class="card" id="topProcessesCard">
      <h2>Top 5 Processes by Memory</h2>
      <table id="topProcessesTable">
        <thead>
          <tr><th>PID</th><th>Name</th><th>Memory (MB)</th></tr>
        </thead>
        <tbody>
          <!-- Filled dynamically -->
        </tbody>
      </table>
    </div>
    
    <!-- Remote Pylons Card -->
    <div class="card" id="remoteCard">
      <h2>Remote Pylons <span id="remotePollIndicator"></span></h2>
      <div id="remoteContainer" style="max-height:300px; overflow-y:auto;"></div>
    </div>
    
    <!-- Remote Viewer Card -->
    <div class="card" id="remoteViewerCard">
      <h2>Remote Viewer üëÄ</h2>
      <div id="remoteView">
        <div><strong>‚ö° CPU:</strong> <span id="rvCpu">0%</span></div>
        <div><strong>üìä RAM:</strong> <span id="rvRam">0%</span></div>
        <div><strong>üíæ Disk:</strong> <span id="rvDisk">0%</span></div>
        <div><strong>üîß CPU Speed:</strong> <span id="rvCpuSpeed">0 GHz</span></div>
        <div id="rvServices" style="margin-top: 10px;"></div>
      </div>
    </div>
  </div>
  
  <!-- Inline JavaScript: Run after DOM is loaded -->
  <script>
  document.addEventListener('DOMContentLoaded', function() {
    // ----------------------
    // Global Variables
    // ----------------------
    var remoteGauges = {};  // Will hold gauges for each remote, keyed by safeKey.
    
    // ----------------------
    // Gauge Initialization for Local Metrics
    // ----------------------
    var cpuGauge = new ProgressBar.Circle('#cpuGauge', {
      color: '#00ff00',
      strokeWidth: 6,
      trailWidth: 2,
      easing: 'easeInOut',
      duration: 800,
      text: { value: '0.00%' },
      from: { color: '#ff4444', width: 2 },
      to: { color: '#00ff00', width: 6 },
      step: function(state, circle) {
        var value = (circle.value() * 100).toFixed(2);
        circle.path.setAttribute('stroke', state.color);
        circle.path.setAttribute('stroke-width', state.width);
        circle.setText(value + '%');
      }
    });
    cpuGauge.text.style.fontFamily = '"Segoe UI", Tahoma, Geneva, Verdana, sans-serif';
    cpuGauge.text.style.fontSize = '1.5rem';
    
    var ramGauge = new ProgressBar.Circle('#ramGauge', {
      color: '#2196F3',
      strokeWidth: 6,
      trailWidth: 2,
      easing: 'easeInOut',
      duration: 800,
      text: { value: '0.00%' },
      from: { color: '#ff5722', width: 2 },
      to: { color: '#2196F3', width: 6 },
      step: function(state, circle) {
        var value = (circle.value() * 100).toFixed(2);
        circle.path.setAttribute('stroke', state.color);
        circle.path.setAttribute('stroke-width', state.width);
        circle.setText(value + '%');
      }
    });
    ramGauge.text.style.fontFamily = '"Segoe UI", Tahoma, Geneva, Verdana, sans-serif';
    ramGauge.text.style.fontSize = '1.5rem';
    
    var diskGauge = new ProgressBar.Circle('#diskGauge', {
      color: '#ffcc00',
      strokeWidth: 6,
      trailWidth: 2,
      easing: 'easeInOut',
      duration: 800,
      text: { value: '0.00%' },
      from: { color: '#ff4444', width: 2 },
      to: { color: '#ffcc00', width: 6 },
      step: function(state, circle) {
        var value = (circle.value() * 100).toFixed(2);
        circle.path.setAttribute('stroke', state.color);
        circle.path.setAttribute('stroke-width', state.width);
        circle.setText(value + '%');
      }
    });
    diskGauge.text.style.fontFamily = '"Segoe UI", Tahoma, Geneva, Verdana, sans-serif';
    diskGauge.text.style.fontSize = '1.5rem';
    
    var cpuSpeedGauge = new ProgressBar.Circle('#cpuSpeedGauge', {
      color: '#ff66cc',
      strokeWidth: 6,
      trailWidth: 2,
      easing: 'easeInOut',
      duration: 800,
      text: { value: '0.00%' },
      from: { color: '#ff4444', width: 2 },
      to: { color: '#ff66cc', width: 6 },
      step: function(state, circle) {
        var value = (circle.value() * 100).toFixed(2);
        circle.path.setAttribute('stroke', state.color);
        circle.path.setAttribute('stroke-width', state.width);
        circle.setText(value + '%');
      }
    });
    cpuSpeedGauge.text.style.fontFamily = '"Segoe UI", Tahoma, Geneva, Verdana, sans-serif';
    cpuSpeedGauge.text.style.fontSize = '1.5rem';
    
    // ----------------------
    // Network Throughput Chart Setup
    // ----------------------
    const ctx = document.getElementById('networkChart').getContext('2d');
    const networkChart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: [],
        datasets: [
          {
            label: 'üì• Received (KB/s)',
            data: [],
            borderColor: 'orange',
            backgroundColor: 'rgba(255,165,0,0.2)',
            fill: false,
            tension: 0.1
          },
          {
            label: 'üì§ Transmitted (KB/s)',
            data: [],
            borderColor: 'cyan',
            backgroundColor: 'rgba(0,255,255,0.2)',
            fill: false,
            tension: 0.1
          }
        ]
      },
      options: {
        scales: {
          x: { title: { display: true, text: 'Time (s)' } },
          y: { title: { display: true, text: 'KB/s' }, beginAtZero: true }
        },
        animation: false,
        responsive: true,
        maintainAspectRatio: false,
      }
    });
    
    var previousReceived = null;
    var previousTransmitted = null;
    var startTime = Date.now();
    const maxDataPoints = 30;
    
    function updateNetworkChart(receivedKBs, transmittedKBs) {
      let nowSec = Math.floor((Date.now() - startTime) / 1000);
      networkChart.data.labels.push(nowSec);
      networkChart.data.datasets[0].data.push(receivedKBs);
      networkChart.data.datasets[1].data.push(transmittedKBs);
      
      if (networkChart.data.labels.length > maxDataPoints) {
        networkChart.data.labels.shift();
        networkChart.data.datasets[0].data.shift();
        networkChart.data.datasets[1].data.shift();
      }
      
      networkChart.update();
    }
    
    // ----------------------
    // Fetch and Update Local Metrics & System Info
    // ----------------------
    async function fetchLocalMetrics() {
      try {
        let response = await fetch('/api/metrics');
        let data = await response.json();
        let polled = data.polled;
        let cached = data.cached;
        let localName = data.name;
        
        document.getElementById('localPylonName').innerText = localName + " üöÄ‚ú®";
        cpuGauge.animate(polled.cpu_usage / 100);
        
        let totalRam = cached.total_ram;
        let usedRam = polled.used_ram;
        let ramPercent = totalRam > 0 ? usedRam / totalRam : 0;
        ramGauge.animate(ramPercent);
        let totalRamGB = (totalRam / 1024 / 1024).toFixed(2);
        let usedRamGB = (usedRam / 1024 / 1024).toFixed(2);
        document.getElementById('ramUsageText').innerText = usedRamGB + " GB / " + totalRamGB + " GB used";
        
        let totalDisk = cached.disk_capacity;
        let usedDisk = totalDisk > 0 ? (totalDisk - polled.disk_free) : 0;
        let diskPercent = totalDisk > 0 ? usedDisk / totalDisk : 0;
        diskGauge.animate(diskPercent);
        let totalDiskGB = (totalDisk / (1024*1024*1024)).toFixed(2);
        let usedDiskGB = (usedDisk / (1024*1024*1024)).toFixed(2);
        document.getElementById('diskUsageText').innerText = usedDiskGB + " GB / " + totalDiskGB + " GB used";
        
        let avgSpeed = cached.average_cpu_speed_mhz;
        let maxSpeed = cached.max_cpu_speed_mhz;
        let speedPercent = maxSpeed > 0 ? avgSpeed / maxSpeed : 0;
        cpuSpeedGauge.animate(speedPercent);
        let avgSpeedGHz = (avgSpeed / 1000).toFixed(2);
        document.getElementById('cpuSpeedText').innerText = avgSpeedGHz + " GHz";
        
        document.getElementById('uptime').innerText = polled.uptime;
        document.getElementById('loadAverage').innerText =
          polled.load_average.one + ' (1m), ' +
          polled.load_average.five + ' (5m), ' +
          polled.load_average.fifteen + ' (15m)';
        
        let newReceived = polled.network_received;
        let newTransmitted = polled.network_transmitted;
        if (previousReceived !== null && previousTransmitted !== null) {
          let deltaReceived = newReceived - previousReceived;
          let deltaTransmitted = newTransmitted - previousTransmitted;
          let throughputReceived = (deltaReceived / 1) / 1024;
          let throughputTransmitted = (deltaTransmitted / 1) / 1024;
          updateNetworkChart(throughputReceived.toFixed(2), throughputTransmitted.toFixed(2));
        }
        previousReceived = newReceived;
        previousTransmitted = newTransmitted;
        
        let bootDate = new Date(cached.boot_time * 1000).toLocaleString();
        let detailsHTML = "<table>" +
                          "<tr><th>Property</th><th>Value</th></tr>" +
                          "<tr><td>üåü OS Version</td><td>" + cached.os_version + "</td></tr>" +
                          "<tr><td>‚öôÔ∏è Apache Version</td><td>" + cached.apache_version + "</td></tr>" +
                          "<tr><td>üêò PHP Version</td><td>" + cached.php_version + "</td></tr>" +
                          "<tr><td>üíΩ MariaDB Version</td><td>" + cached.mariadb_version + "</td></tr>" +
                          "<tr><td>ü¶Ä Rust Version</td><td>" + cached.rust_version + "</td></tr>" +
                          "<tr><td>üìü Node Version</td><td>" + cached.node_version + "</td></tr>" +
                          "<tr><td>üì¶ npm Version</td><td>" + cached.npm_version + "</td></tr>" +
                          "<tr><td>üîß Processor</td><td>" + cached.processor + "</td></tr>" +
                          "<tr><td>üíæ Total RAM</td><td>" + totalRamGB + " GB</td></tr>" +
                          "<tr><td>üíø Disk Capacity</td><td>" + totalDiskGB + " GB</td></tr>" +
                          "<tr><td>üìÄ Disk Usage</td><td>" + usedDiskGB + " GB</td></tr>" +
                          "<tr><td>‚è∞ Boot Time</td><td>" + bootDate + "</td></tr>" +
                          "<tr><td>‚ö° CPU Speed</td><td>" + avgSpeedGHz + " GHz (avg)</td></tr>" +
                          "</table>";
        document.getElementById('systemDetails').innerHTML = detailsHTML;
        
        let topProcessesTableBody = document.getElementById('topProcessesTable').getElementsByTagName('tbody')[0];
        topProcessesTableBody.innerHTML = "";
        if (polled.top_processes && polled.top_processes.length > 0) {
          polled.top_processes.forEach(proc => {
            let row = document.createElement('tr');
            let pidCell = document.createElement('td');
            pidCell.innerText = proc.pid;
            let nameCell = document.createElement('td');
            nameCell.innerText = proc.name;
            let memCell = document.createElement('td');
            let memMB = (proc.memory / 1024).toFixed(2);
            memCell.innerText = memMB;
            row.appendChild(pidCell);
            row.appendChild(nameCell);
            row.appendChild(memCell);
            topProcessesTableBody.appendChild(row);
          });
        }
        
        let servicesDiv = document.getElementById('servicesStatus');
        servicesDiv.innerHTML = "";
        polled.services.forEach(service => {
          let serviceDiv = document.createElement('div');
          serviceDiv.className = "service";
          let light = document.createElement('div');
          light.className = "service-light";
          light.style.backgroundColor = service.running ? "limegreen" : "red";
          light.style.boxShadow = service.running ? "0 0 10px limegreen" : "0 0 10px red";
          let label = document.createElement('div');
          label.innerText = service.name;
          serviceDiv.appendChild(light);
          serviceDiv.appendChild(label);
          servicesDiv.appendChild(serviceDiv);
        });
        
        document.getElementById('rvCpu').innerText = (polled.cpu_usage).toFixed(2) + "%";
        document.getElementById('rvRam').innerText = (ramPercent * 100).toFixed(2) + "%";
        document.getElementById('rvDisk').innerText = (diskPercent * 100).toFixed(2) + "%";
        let rvSpeedText = (avgSpeed / 1000).toFixed(2) + " GHz";
        if(document.getElementById('rvCpuSpeed')) {
          document.getElementById('rvCpuSpeed').innerText = rvSpeedText;
        }
        
      } catch (err) {
        console.error('Error fetching local metrics:', err);
      }
    }
    
    // ----------------------
    // Fetch and Update Remote Pylon Metrics (Persistent Remote Blocks & Gauges)
    // ----------------------
    async function fetchRemoteMetrics() {
      try {
        let indicator = document.getElementById('remotePollIndicator');
        indicator.innerHTML = '<span class="pulse">üåê</span>';
        setTimeout(() => { indicator.innerHTML = ''; }, 1500);
        
        let response = await fetch('/api/remotes');
        let remotes = await response.json();
        let container = document.getElementById('remoteContainer');
        
        remotes.forEach(remote => {
          let safeKey = remote.ip.replace(/\./g, '_') + "_" + remote.port;
          let remoteBlock = document.getElementById('remote_' + safeKey);
          if (!remoteBlock) {
            // Create a new remote block if it doesn't exist
            remoteBlock = document.createElement('div');
            remoteBlock.id = 'remote_' + safeKey;
            remoteBlock.style.border = '1px solid #444';
            remoteBlock.style.padding = '10px';
            remoteBlock.style.marginBottom = '10px';
            remoteBlock.style.borderRadius = '5px';
            remoteBlock.style.backgroundColor = '#2a2a2a';
            
            let header = document.createElement('h3');
            header.style.margin = '0 0 10px';
            let remoteDisplayName = (remote.data && remote.data.name) ? remote.data.name : (remote.ip + ':' + remote.port);
            header.innerText = "üåç " + remoteDisplayName;
            remoteBlock.appendChild(header);
            
            let gaugesContainer = document.createElement('div');
            gaugesContainer.id = 'gauges_' + safeKey;
            gaugesContainer.style.display = "flex";
            gaugesContainer.style.flexWrap = "wrap";
            gaugesContainer.style.gap = "10px";
            remoteBlock.appendChild(gaugesContainer);
            
            // CPU Gauge
            let cpuGaugeContainer = document.createElement('div');
            cpuGaugeContainer.className = "gauge-container";
            cpuGaugeContainer.style.width = "120px";
            let cpuGaugeDiv = document.createElement('div');
            let cpuGaugeId = 'cpuGauge_' + safeKey;
            cpuGaugeDiv.id = cpuGaugeId;
            cpuGaugeDiv.className = "gauge";
            cpuGaugeDiv.style.width = "100px";
            cpuGaugeDiv.style.height = "100px";
            cpuGaugeContainer.appendChild(cpuGaugeDiv);
            let cpuLabel = document.createElement('div');
            cpuLabel.className = "gauge-label";
            cpuLabel.innerText = "‚ö° CPU";
            cpuGaugeContainer.appendChild(cpuLabel);
            gaugesContainer.appendChild(cpuGaugeContainer);
            
            // RAM Gauge
            let ramGaugeContainer = document.createElement('div');
            ramGaugeContainer.className = "gauge-container";
            ramGaugeContainer.style.width = "120px";
            let ramGaugeDiv = document.createElement('div');
            let ramGaugeId = 'ramGauge_' + safeKey;
            ramGaugeDiv.id = ramGaugeId;
            ramGaugeDiv.className = "gauge";
            ramGaugeDiv.style.width = "100px";
            ramGaugeDiv.style.height = "100px";
            ramGaugeContainer.appendChild(ramGaugeDiv);
            let ramLabel = document.createElement('div');
            ramLabel.className = "gauge-label";
            ramLabel.innerText = "üìä RAM";
            ramGaugeContainer.appendChild(ramLabel);
            let ramText = document.createElement('div');
            ramText.id = 'ramText_' + safeKey;
            ramText.style.fontSize = "0.9rem";
            ramGaugeContainer.appendChild(ramText);
            gaugesContainer.appendChild(ramGaugeContainer);
            
            // Disk Gauge
            let diskGaugeContainer = document.createElement('div');
            diskGaugeContainer.className = "gauge-container";
            diskGaugeContainer.style.width = "120px";
            let diskGaugeDiv = document.createElement('div');
            let diskGaugeId = 'diskGauge_' + safeKey;
            diskGaugeDiv.id = diskGaugeId;
            diskGaugeDiv.className = "gauge";
            diskGaugeDiv.style.width = "100px";
            diskGaugeDiv.style.height = "100px";
            diskGaugeContainer.appendChild(diskGaugeDiv);
            let diskLabel = document.createElement('div');
            diskLabel.className = "gauge-label";
            diskLabel.innerText = "üíæ Disk";
            diskGaugeContainer.appendChild(diskLabel);
            let diskText = document.createElement('div');
            diskText.id = 'diskText_' + safeKey;
            diskText.style.fontSize = "0.9rem";
            diskGaugeContainer.appendChild(diskText);
            gaugesContainer.appendChild(diskGaugeContainer);
            
            // CPU Speed Gauge
            let cpuSpeedGaugeContainer = document.createElement('div');
            cpuSpeedGaugeContainer.className = "gauge-container";
            cpuSpeedGaugeContainer.style.width = "120px";
            let cpuSpeedGaugeDiv = document.createElement('div');
            let cpuSpeedGaugeId = 'cpuSpeedGauge_' + safeKey;
            cpuSpeedGaugeDiv.id = cpuSpeedGaugeId;
            cpuSpeedGaugeDiv.className = "gauge";
            cpuSpeedGaugeDiv.style.width = "100px";
            cpuSpeedGaugeDiv.style.height = "100px";
            cpuSpeedGaugeContainer.appendChild(cpuSpeedGaugeDiv);
            let cpuSpeedLabel = document.createElement('div');
            cpuSpeedLabel.className = "gauge-label";
            cpuSpeedLabel.innerText = "üîß Speed";
            cpuSpeedGaugeContainer.appendChild(cpuSpeedLabel);
            let cpuSpeedText = document.createElement('div');
            cpuSpeedText.id = 'cpuSpeedText_' + safeKey;
            cpuSpeedText.style.fontSize = "0.9rem";
            cpuSpeedGaugeContainer.appendChild(cpuSpeedText);
            gaugesContainer.appendChild(cpuSpeedGaugeContainer);
            
            container.appendChild(remoteBlock);
            
            remoteGauges[safeKey] = {
              cpu: new ProgressBar.Circle('#' + cpuGaugeId, {
                        color: '#00ff00',
                        strokeWidth: 4,
                        trailWidth: 2,
                        easing: 'easeInOut',
                        duration: 800,
                        text: { value: '0.00%' },
                        from: { color: '#ff4444', width: 2 },
                        to: { color: '#00ff00', width: 4 },
                        step: function(state, circle) {
                          var value = (circle.value() * 100).toFixed(2);
                          circle.path.setAttribute('stroke', state.color);
                          circle.path.setAttribute('stroke-width', state.width);
                          circle.setText(value + '%');
                        }
                      }),
              ram: new ProgressBar.Circle('#' + ramGaugeId, {
                        color: '#2196F3',
                        strokeWidth: 4,
                        trailWidth: 2,
                        easing: 'easeInOut',
                        duration: 800,
                        text: { value: '0.00%' },
                        from: { color: '#ff5722', width: 2 },
                        to: { color: '#2196F3', width: 4 },
                        step: function(state, circle) {
                          var value = (circle.value() * 100).toFixed(2);
                          circle.path.setAttribute('stroke', state.color);
                          circle.path.setAttribute('stroke-width', state.width);
                          circle.setText(value + '%');
                        }
                      }),
              disk: new ProgressBar.Circle('#' + diskGaugeId, {
                        color: '#ffcc00',
                        strokeWidth: 4,
                        trailWidth: 2,
                        easing: 'easeInOut',
                        duration: 800,
                        text: { value: '0.00%' },
                        from: { color: '#ff4444', width: 2 },
                        to: { color: '#ffcc00', width: 4 },
                        step: function(state, circle) {
                          var value = (circle.value() * 100).toFixed(2);
                          circle.path.setAttribute('stroke', state.color);
                          circle.path.setAttribute('stroke-width', state.width);
                          circle.setText(value + '%');
                        }
                      }),
              cpuSpeed: new ProgressBar.Circle('#' + cpuSpeedGaugeId, {
                        color: '#ff66cc',
                        strokeWidth: 4,
                        trailWidth: 2,
                        easing: 'easeInOut',
                        duration: 800,
                        text: { value: '0.00%' },
                        from: { color: '#ff4444', width: 2 },
                        to: { color: '#ff66cc', width: 4 },
                        step: function(state, circle) {
                          var value = (circle.value() * 100).toFixed(2);
                          circle.path.setAttribute('stroke', state.color);
                          circle.path.setAttribute('stroke-width', state.width);
                          circle.setText(value + '%');
                        }
                      })
            };
            remoteGauges[safeKey].cpu.text.style.fontFamily = '"Segoe UI", Tahoma, Geneva, Verdana, sans-serif';
            remoteGauges[safeKey].cpu.text.style.fontSize = '1rem';
            remoteGauges[safeKey].ram.text.style.fontFamily = '"Segoe UI", Tahoma, Geneva, Verdana, sans-serif';
            remoteGauges[safeKey].ram.text.style.fontSize = '1rem';
            remoteGauges[safeKey].disk.text.style.fontFamily = '"Segoe UI", Tahoma, Geneva, Verdana, sans-serif';
            remoteGauges[safeKey].disk.text.style.fontSize = '1rem';
            remoteGauges[safeKey].cpuSpeed.text.style.fontFamily = '"Segoe UI", Tahoma, Geneva, Verdana, sans-serif';
            remoteGauges[safeKey].cpuSpeed.text.style.fontSize = '1rem';
          }
          
          // Update the gauges if the remote is online.
          if (remote.online && remote.data) {
            let polled = remote.data.polled;
            let cached = remote.data.cached;
            remoteGauges[safeKey].cpu.animate(polled.cpu_usage / 100);
            
            let totalRam = cached.total_ram;
            let usedRam = polled.used_ram;
            let ramPercent = totalRam > 0 ? usedRam / totalRam : 0;
            remoteGauges[safeKey].ram.animate(ramPercent);
            let totalRamGB = (totalRam / 1024 / 1024).toFixed(2);
            let usedRamGB = (usedRam / 1024 / 1024).toFixed(2);
            document.getElementById('ramText_' + safeKey).innerText = usedRamGB + " GB / " + totalRamGB + " GB";
            
            let totalDisk = cached.disk_capacity;
            let usedDisk = totalDisk > 0 ? (totalDisk - polled.disk_free) : 0;
            let diskPercent = totalDisk > 0 ? usedDisk / totalDisk : 0;
            remoteGauges[safeKey].disk.animate(diskPercent);
            let totalDiskGB = (totalDisk / (1024*1024*1024)).toFixed(2);
            let usedDiskGB = (usedDisk / (1024*1024*1024)).toFixed(2);
            document.getElementById('diskText_' + safeKey).innerText = usedDiskGB + " GB / " + totalDiskGB + " GB";
            
            let avgSpeed = cached.average_cpu_speed_mhz;
            let maxSpeed = cached.max_cpu_speed_mhz;
            let speedPercent = maxSpeed > 0 ? avgSpeed / maxSpeed : 0;
            remoteGauges[safeKey].cpuSpeed.animate(speedPercent);
            let avgSpeedGHz = (avgSpeed / 1000).toFixed(2);
            document.getElementById('cpuSpeedText_' + safeKey).innerText = avgSpeedGHz + " GHz";
          } else {
            // If offline, show an offline indicator.
            let remoteBlock = document.getElementById('remote_' + safeKey);
            remoteBlock.innerHTML = '<div style="font-size:1.5rem; text-align:center;"><span class="pulse">üåê‚ùå</span></div>';
          }
        });
      } catch (err) {
        console.error('Error fetching remote metrics:', err);
      }
    }
    
    async function updateDashboard() {
      await fetchLocalMetrics();
      await fetchRemoteMetrics();
    }
    
    setInterval(updateDashboard, 1000);
    updateDashboard();
  });
  </script>
</body>
</html>"#;
    HttpResponse::Ok().content_type("text/html").body(html)
}

#[get("/api/metrics")]
async fn metrics(data: web::Data<AppState>, _req: HttpRequest) -> impl Responder {
    let sys_data = data.system_data.lock().unwrap();
    let config = data.config.read().unwrap();
    let local_name = config.name.clone().unwrap_or_else(|| "Local Pylon".to_string());
    let response = json!({
        "name": local_name,
        "cached": sys_data.cached,
        "polled": sys_data.polled,
        "remote_pylons": config.remote_pylons,
    });
    HttpResponse::Ok().json(response)
}

#[get("/api/remotes")]
async fn remotes(data: web::Data<AppState>) -> impl Responder {
    let statuses = data.remote_statuses.lock().unwrap();
    let response: Vec<_> = statuses.values().cloned().collect();
    HttpResponse::Ok().json(response)
}

async fn port_available(port: u16) -> bool {
    use tokio::net::TcpListener;
    match TcpListener::bind(("127.0.0.1", port)).await {
        Ok(_) => true,
        Err(_) => false,
    }
}

pub async fn find_open_port(start_port: u16) -> u16 {
    let mut port = start_port;
    loop {
        if port_available(port).await {
            break;
        }
        port += 1;
    }
    port
}

pub async fn run_server(port: u16, state: AppState) -> std::io::Result<()> {
    println!("Starting server on http://127.0.0.1:{}", port);
    HttpServer::new(move || {
        App::new()
            .app_data(web::Data::new(state.clone()))
            .wrap(Logger::default())
            .service(index)
            .service(metrics)
            .service(remotes)
    })
    .bind(("0.0.0.0", port))?
    .run()
    .await
}

================
File: system_info.rs
================
// src/system_info.rs

use sysinfo::{System, SystemExt, CpuExt, DiskExt, NetworkExt, LoadAvg, ProcessExt, PidExt};
use tokio::time::{sleep, Duration};
use serde::Serialize;
use std::sync::{Mutex, Arc};

#[derive(Debug, Serialize, Clone)]
pub struct CachedInfo {
    pub os_version: String,
    pub apache_version: String,
    pub php_version: String,
    pub mariadb_version: String,
    pub rust_version: String,
    pub node_version: String,
    pub npm_version: String,
    pub processor: String,
    pub total_ram: u64,
    pub disk_capacity: u64,
    pub disk_usage: u64,
    pub boot_time: u64,
    // New: average and maximum CPU speed in MHz
    pub average_cpu_speed_mhz: u64,
    pub max_cpu_speed_mhz: u64,
}

#[derive(Debug, Serialize, Clone)]
pub struct ServiceStatus {
    pub name: String,
    pub running: bool,
}

#[derive(Debug, Serialize, Clone)]
pub struct ProcessInfo {
    pub pid: u32,
    pub name: String,
    pub memory: u64, // memory in KB
}

#[derive(Debug, Serialize, Clone, Default)]
pub struct PolledMetrics {
    pub cpu_usage: f32,
    pub used_ram: u64,
    pub available_ram: u64,
    pub network_received: u64,
    pub network_transmitted: u64,
    pub uptime: u64,
    pub load_average: LoadAvg,
    pub swap_used: u64,
    pub swap_total: u64,
    pub disk_free: u64,
    pub disk_usage_percent: f32,
    pub services: Vec<ServiceStatus>,
    pub top_processes: Vec<ProcessInfo>,
}

#[derive(Debug, Clone)]
pub struct SystemData {
    pub cached: CachedInfo,
    pub polled: PolledMetrics,
}

impl SystemData {
    pub fn new() -> Self {
        let mut sys = System::new_all();
        // Refresh once to get initial values.
        sys.refresh_all();

        // Compute disk totals.
        let (total_capacity, total_usage) = sys.disks().iter().fold((0, 0), |(cap, used), disk| {
            (cap + disk.total_space(), used + (disk.total_space() - disk.available_space()))
        });

        // Compute CPU speed from all available CPUs.
        let cpus = sys.cpus();
        let (avg_cpu_speed, max_cpu_speed) = if !cpus.is_empty() {
            let total: u64 = cpus.iter().map(|cpu| cpu.frequency()).sum();
            let avg = total / (cpus.len() as u64);
            let max = cpus.iter().map(|cpu| cpu.frequency()).max().unwrap_or(avg);
            (avg, max)
        } else {
            (0, 0)
        };

        let cached = CachedInfo {
            os_version: get_os_version(),
            apache_version: get_command_version("apache2", "-v"),
            php_version: get_command_version("php", "-v"),
            mariadb_version: get_command_version("mysql", "--version"),
            rust_version: get_command_version("rustc", "--version"),
            node_version: get_command_version("node", "-v"),
            npm_version: get_command_version("npm", "-v"),
            processor: get_processor_info(),
            total_ram: sys.total_memory(),
            disk_capacity: total_capacity,
            disk_usage: total_usage,
            boot_time: sys.boot_time(),
            average_cpu_speed_mhz: avg_cpu_speed,
            max_cpu_speed_mhz: max_cpu_speed,
        };

        Self {
            cached,
            polled: PolledMetrics::default(),
        }
    }
}

fn get_os_version() -> String {
    if let Ok(content) = std::fs::read_to_string("/etc/os-release") {
        for line in content.lines() {
            if line.starts_with("PRETTY_NAME=") {
                return line.replace("PRETTY_NAME=", "").replace("\"", "");
            }
        }
    }
    "Unknown OS".to_string()
}

fn get_command_version(cmd: &str, arg: &str) -> String {
    if let Ok(output) = std::process::Command::new(cmd).arg(arg).output() {
        if output.status.success() {
            let s = String::from_utf8_lossy(&output.stdout).to_string();
            return s.lines().next().unwrap_or("Unknown").to_string();
        }
    }
    "Not installed".to_string()
}

fn get_processor_info() -> String {
    if let Ok(content) = std::fs::read_to_string("/proc/cpuinfo") {
        for line in content.lines() {
            if line.starts_with("model name") {
                let parts: Vec<&str> = line.split(':').collect();
                if parts.len() > 1 {
                    return parts[1].trim().to_string();
                }
            }
        }
    }
    "Unknown Processor".to_string()
}

/// Poll system metrics (including the top five memory‚Äêhungry processes)
pub async fn poll_system_metrics(data: Arc<Mutex<SystemData>>, mut shutdown: tokio::sync::watch::Receiver<bool>) {
    let mut sys = System::new_all();
    loop {
        if *shutdown.borrow() {
            println!("Shutting down system metrics poller.");
            break;
        }
        sys.refresh_all();

        let cpu_usage = sys.global_cpu_info().cpu_usage();
        let used_ram = sys.used_memory();
        let available_ram = sys.available_memory();

        // Calculate disk usage.
        let (total_capacity, total_free) = sys.disks().iter().fold((0, 0), |(cap, free), disk| {
            (cap + disk.total_space(), free + disk.available_space())
        });
        let used_disk = if total_capacity > 0 { total_capacity - total_free } else { 0 };
        let disk_usage_percent = if total_capacity > 0 {
            used_disk as f32 / total_capacity as f32
        } else { 0.0 };

        // Sum network stats.
        let (mut network_received, mut network_transmitted) = (0, 0);
        for (_iface, data_net) in sys.networks() {
            network_received += data_net.received();
            network_transmitted += data_net.transmitted();
        }

        let uptime = sys.uptime();
        let load_average = sys.load_average();
        let swap_total = sys.total_swap();
        let swap_used = sys.used_swap();

        // Check for service statuses.
        let mut apache_running = false;
        let mut mariadb_running = false;
        for process in sys.processes().values() {
            let proc_name = process.name().to_lowercase();
            if proc_name.contains("apache2") {
                apache_running = true;
            }
            if proc_name.contains("mariadb") || proc_name.contains("mysql") {
                mariadb_running = true;
            }
        }
        let services = vec![
            ServiceStatus { name: "Apache2".into(), running: apache_running },
            ServiceStatus { name: "MariaDB".into(), running: mariadb_running },
        ];

        // Calculate top 5 processes by memory usage.
        let mut processes: Vec<_> = sys.processes().values().collect();
        processes.sort_by(|a, b| b.memory().cmp(&a.memory()));
        let top_processes: Vec<ProcessInfo> = processes.iter().take(5).map(|process| ProcessInfo {
            pid: process.pid().as_u32(),
            name: process.name().to_string(),
            memory: process.memory(),
        }).collect();

        // Update CPU speed info on each poll.
        let cpus = sys.cpus();
        let (avg_cpu_speed, max_cpu_speed) = if !cpus.is_empty() {
            let total: u64 = cpus.iter().map(|cpu| cpu.frequency()).sum();
            let avg = total / (cpus.len() as u64);
            let max = cpus.iter().map(|cpu| cpu.frequency()).max().unwrap_or(avg);
            (avg, max)
        } else {
            (0, 0)
        };

        {
            let mut data_lock = data.lock().unwrap();
            data_lock.polled.cpu_usage = cpu_usage;
            data_lock.polled.used_ram = used_ram;
            data_lock.polled.available_ram = available_ram;
            data_lock.polled.network_received = network_received;
            data_lock.polled.network_transmitted = network_transmitted;
            data_lock.polled.uptime = uptime;
            data_lock.polled.load_average = load_average;
            data_lock.polled.swap_total = swap_total;
            data_lock.polled.swap_used = swap_used;
            data_lock.polled.disk_free = total_free;
            data_lock.polled.disk_usage_percent = disk_usage_percent;
            data_lock.polled.services = services;
            data_lock.polled.top_processes = top_processes;
            data_lock.cached.average_cpu_speed_mhz = avg_cpu_speed;
            data_lock.cached.max_cpu_speed_mhz = max_cpu_speed;
        }

        tokio::select! {
            _ = shutdown.changed() => {
                if *shutdown.borrow() {
                    println!("Shutting down system metrics poller.");
                    break;
                }
            },
            _ = sleep(Duration::from_secs(1)) => {}
        }
    }
}
